## 正则表达式

### 正则创建方式

- 方式一: 字面量方式
- 字面量无法拼接变量

```js
const reg = /\d/g;
```

- 方式二：构造函数

```js
const reg  = new RegExp('\d','aa');
```

**常用修饰符**

- `i`：忽略大小写匹配
- `g`：找到全部
- `m`:多行匹配,遇到换行不停止匹配

### 字符集合和范围类[]

- 字符串集合和范围类都是使用中括号[]定义的区别:范围类在中括号中定义，范围类在中括号中使用`-`连接

| 表达式 | 说明                       | 示例                         | 返回结果  |
| ------ | -------------------------- | ---------------------------- | --------- |
| [abc]  | 匹配中括号内的任意字符     | `abdddddba``.macth(/[ab]/g)` | `a,b,b,a` |
| [^abc] | 匹配不在中括号中的任意字符 | `aopcada.macth(/[^ab]/g)`    | `o,p,c,d` |
| [0-9]  | 匹配任何从0至9的数字       | `abc021.macth(/[0-9]/g)`     | `0,2,1`   |
| [a-z]  | 匹配任何从小写a至z的字符   | `abc123.macth(/[a-z]/g)`     | `a,b,c`   |
| [A-Z]  | 匹配任何从小写A至Z的字符   | `ABC13.macth([/[A-Z]/g)`     | `A,B,C`   |

### 元字符类

`.` 匹配任意单个字符,除换行和结束符

`\d`匹配数字,等价于[0-9]

`\D`匹配非数字,等价于`[^0-9]`

`\s`匹配空白符主要有(`\n`、`\f`、`\t`、`\v`)

`\S`匹配非空白符

`\w`匹配任意单词字符(数字、字母、下划线)等价于[A-Za-z0-9]

`\W`匹配任意非单词字符

### 边界类

`^`匹配字符串的开始 `/^a/匹配an A`而不匹配`An a `

- 限定开头

`$`匹配字符串的结束`/^$/匹配An a`而不匹配a An

`\b`匹配单词的开始或结束`/\bno/`匹配`atnnon`中的no

### 量词类

- `*` 重复零次或更多次 ，不建议使用 会有很多逗号
- `+` 重复一次或更多次(至少有一次)
- `?`重复一次或多次(可有可无)
- `{n}`重复n次
- `{n,m}`至少`n`次最多`m`次
- `{n,}`至少`n次`

### 特殊符号类



### 捕获分组与非捕获分组

- js常用捕获
  - `(?=)` 正向前瞻型捕获
  - `(?!)`负向前瞻型捕获
  - `(?<=)`正向后顾型捕获
  - `(?<!)`负向后顾性捕获
  - `(?:)`非捕获分组

- 起组名
  - 一般情况下不需要起名,用默认的`$1,$2`,`js起名用：?<xxx>`,js引用分组`\k<组名>`,默认使用`\数字`

**匹配对象前后有固定字符串**

```js
{"departmentId":1,
"departmentName":"zzz",
	"child":[{"departmentId":2,
				"departmentName":"测试部门",
				"child":[{"departmentId":5,
						"departmentName":"试试"}
						]},
			{"departmentId":3,
			"departmentName":"威风威风",
			"child":[{"departmentId":6,"departmentName":"试试44"}]
			},
			{"departmentId":4,"departmentName":"测试部门2"}
	]
}

```

需求:把所有`departmentName`层级拿出来

前面固定字符,后面固定引号,由于js分组无法取全局,所以借助捕获符直接提取目标格式是:

`(?<=前面的字符)(中间的内容)(?=后面的字符串)`这个分组就是前瞻后顾捕获

```js
let jsop = JSON.stringify(str);
let reg = /(?<="departmentName"\:)(.*?)(?=")/g;
console.log(jsop.match(reg));
```

### 贪婪与非贪婪模式

默认使用贪婪模式尽可能多的匹配

在重复量词后面加一个？,代表使用非贪婪模式尽可能多的匹配

```js
"1234567".match(/\d{2,5}/);
 //默认贪婪模式(尽可能匹配多)[12345]
//转成非贪婪模式
"123456".match(/\d(2，5)?/)//12
```

**正向肯定查找和正向否定查找**